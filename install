#!/usr/bin/env bash
# -------------------------------------------------------------------------------
# Script d'installation : Kubernetes 1.24 + KubeSphere 3.3.x sur Ubuntu 22.04/24.04
# + Configuration CLI GitHub pour l'utilisateur 'charlesdd'
#
# - Purge anciens dépôts Kubernetes xenial
# - Détection automatique des miroirs (deb.k8s.io → pkgs.k8s.io → aliyun)
# - Gestion clés GPG miroirs
# - Déploiement Local-Path provisioner & StorageClass par défaut
# - Suppression des taints control-plane pour cluster single-node
# - Logging complet dans /var/log/kubesphere-install-<DATE>.log
# - Installation de GitHub CLI (gh) et authentification non-interactive
# -------------------------------------------------------------------------------
set -euo pipefail

LOGFILE="/var/log/kubesphere-install-$(date +%F_%H-%M-%S).log"
exec > >(tee -a "$LOGFILE") 2>&1

POD_CIDR="10.233.0.0/18"
K8S_VER="1.24.17-00"    # dernière 1.24.x disponible sur tous les miroirs

##############################
### 0. Pré-requis de base ###
##############################

# Désactivation du swap
swapoff -a || true
sed -i '/swap/ s/^/#/' /etc/fstab

# Modules noyau nécessaires
cat >/etc/modules-load.d/k8s.conf <<EOF
overlay
br_netfilter
EOF
modprobe overlay || true
modprobe br_netfilter || true

# Paramètres sysctl pour Kubernetes
cat >/etc/sysctl.d/k8s.conf <<EOF
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF
sysctl --system

# Mise à jour & installation des paquets de base
apt update
DEBIAN_FRONTEND=noninteractive apt install -y \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg \
    lsb-release \
    ufw \
    bash-completion \
    net-tools \
    software-properties-common

####################################################
### 1. Purge d'anciens dépôts Kubernetes (xenial) ###
####################################################
find /etc/apt/sources.list.d -type f -name '*kubernetes*.list' -delete || true
sed -i '/kubernetes/d' /etc/apt/sources.list || true

############################################################
### 2. Détection miroir Kubernetes + récupération des clés ###
############################################################
mkdir -p /etc/apt/keyrings

declare -A MIRRORS=( 
  [debk8s]="https://deb.k8s.io/ kubernetes-xenial main|google"
  [pkgs]  ="https://pkgs.k8s.io/core/stable/v1.24/deb/ /|google"
  [aliyun]="https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main|aliyun"
)
CHOSEN_URL=""
CHOSEN_KEY=""
for key in debk8s pkgs aliyun; do
  IFS='|' read -r URL KEY <<< "${MIRRORS[$key]}"
  TEST_URL=$(awk '{print $1}' <<< "$URL")"dists/kubernetes-xenial/Release"
  echo "[INFO] Test $key … ($TEST_URL)"
  if curl -fs --connect-timeout 5 "$TEST_URL" >/dev/null; then
    CHOSEN_URL="$URL"
    CHOSEN_KEY="$KEY"
    echo "[OK]  $key retenu"
    break
  else
    echo "[WARN] $key indisponible"
  fi
done
if [[ -z "$CHOSEN_URL" ]]; then
  echo "[FATAL] Aucun dépôt Kubernetes accessible." >&2
  exit 1
fi

# Récupérer la clé GPG selon le miroir choisi
if [[ "$CHOSEN_KEY" == "google" ]]; then
  curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg \
    | gpg --dearmor -o /etc/apt/keyrings/kubernetes-archive-keyring.gpg
  KEYFILE=/etc/apt/keyrings/kubernetes-archive-keyring.gpg
else
  curl -fsSL https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg \
    | gpg --dearmor -o /etc/apt/keyrings/kubernetes-aliyun.gpg
  KEYFILE=/etc/apt/keyrings/kubernetes-aliyun.gpg
fi

echo "deb [signed-by=$KEYFILE] $CHOSEN_URL" \
  >/etc/apt/sources.list.d/kubernetes.list

###############################################################
### 3. Installation containerd + Kubernetes (kubeadm, etc.) ###
###############################################################

# 3.1 Installer containerd depuis Docker upstream
curl -fsSL https://download.docker.com/linux/ubuntu/gpg \
  | gpg --dearmor -o /etc/apt/keyrings/docker.gpg

echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \
https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" \
  >/etc/apt/sources.list.d/docker.list

apt update
DEBIAN_FRONTEND=noninteractive apt install -y containerd.io

# Configurer containerd
mkdir -p /etc/containerd
containerd config default >/etc/containerd/config.toml
# activer cgroup v2 si nécessaire (SystemdCgroup à true)
sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml
systemctl restart containerd && systemctl enable containerd

# 3.2 Installer kubelet, kubeadm, kubectl
DEBIAN_FRONTEND=noninteractive apt install -y \
  kubelet="${K8S_VER}" \
  kubeadm="${K8S_VER}" \
  kubectl="${K8S_VER}"
apt-mark hold kubelet kubeadm kubectl

##############################################
### 4. Initialiser le cluster control-plane ###
##############################################

kubeadm init \
  --pod-network-cidr="${POD_CIDR}" \
  --cri-socket=unix:///run/containerd/containerd.sock

# Configurer kubectl pour l'utilisateur courant
mkdir -p /home/ubuntu/.kube
cp -i /etc/kubernetes/admin.conf /home/ubuntu/.kube/config
chown ubuntu:ubuntu /home/ubuntu/.kube/config

######################################
### 5. Déployer CNI Calico (v1.24+) ###
######################################

curl -sSL https://docs.projectcalico.org/manifests/calico.yaml \
  | sed "s#192.168.0.0/16#${POD_CIDR}#" \
  | kubectl apply -f -

############################################################
### 6. Provisioner local-path + StorageClass par défaut ###
############################################################

kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/master/deploy/local-path-storage.yaml

# Rendre local-path la StorageClass par défaut
kubectl patch storageclass local-path \
  -p '{"metadata":{"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'

###################################################
### 7. Retirer le taint control-plane (single-node) ###
###################################################

kubectl taint nodes --all node-role.kubernetes.io/control-plane- || true
kubectl taint nodes --all node-role.kubernetes.io/master-          || true

#############################################
### 8. Déployer KubeSphere 3.3.2 (installer) ###
#############################################

kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.3.2/kubesphere-installer.yaml
kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.3.2/cluster-configuration.yaml

echo "[INFO] ks-installer lancé — suivez le log avec :"
echo "       kubectl logs -f -n kubesphere-system \$(kubectl get pod -n kubesphere-system -l app=ks-installer -o name)"

auto_wait() {
  local label="$1"
  local ns="$2"
  local selector="$3"
  echo -n "[INFO] Attente de $label …"
  until kubectl get pod -n "$ns" -l "$selector" 2>/dev/null | grep -q "Running"; do
    echo -n "."; sleep 5;
  done
  echo " OK"
}

auto_wait "Calico"         kube-system     "k8s-app=calico-node"
auto_wait "ks-installer"   kubesphere-system "app=ks-installer"

echo -e "\n#####################################################"
echo "###              Welcome to KubeSphere!          ###"
echo "#####################################################"
echo "Console : http://$(hostname -I | awk '{print \$1}'):30880"
echo "Compte  : admin"
echo "Password: P@88w0rd"
echo "NOTES : 1) Changez le mot de passe après connexion."
echo "        2) Patientez jusqu'à ce que tous les pods "
echo "           KubeSphere passent en Running.          "
echo "#####################################################"

###########################################
### 9. Configuration du pare-feu UFW      ###
###########################################

ufw default deny incoming
ufw default allow outgoing
ufw allow 22/tcp
ufw allow 30880/tcp
ufw --force enable

#############################################
### 10. Installer & configurer GitHub CLI ###
#############################################

# Installer GitHub CLI (deb) selon la doc officielle
curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
  | gpg --dearmor -o /etc/apt/keyrings/githubcli-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] \
https://cli.github.com/packages stable main" \
  >/etc/apt/sources.list.d/github-cli.list

apt update
DEBIAN_FRONTEND=noninteractive apt install -y gh

# Authentification non-interactive de l'utilisateur `charlesdd`
USER_GH="charlesdd"
GH_PAT="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"

# Créer l’utilisateur s’il n’existe pas, lui donner un home et un shell bash
if ! id -u "$USER_GH" >/dev/null 2>&1; then
  useradd -m -s /bin/bash "$USER_GH"
fi

# Stocker le token dans un fichier sécurisé dans le home de charlesdd
GH_CONFIG_DIR="/home/$USER_GH/.config/gh"
mkdir -p "$GH_CONFIG_DIR"
echo "$GH_PAT" > "$GH_CONFIG_DIR/token"
chown -R "$USER_GH:$USER_GH" "/home/$USER_GH/.config"

# Effectuer la connexion automatique au compte GitHub
# on passe le token via stdin, en tant qu’utilisateur charlesdd
sudo -u "$USER_GH" gh auth login --with-token < "$GH_CONFIG_DIR/token"

echo "[INFO] GitHub CLI configurée pour l'utilisateur '$USER_GH'."

echo "[SUCCESS] Installation terminée."
